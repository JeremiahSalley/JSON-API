import * as t from 'io-ts';
import { ExchangeChannel } from '../../../sockets/crypto/common';
export declare namespace ExchangeFuturesTypes {
    type FuturesSnapshot<C extends ExchangeChannel, E extends FuturesExchange> = t.TypeOf<typeof ExchangeFuturesTypes.DataTypes[C][E]['snapshot']>;
    type FuturesData<C extends ExchangeChannel, E extends FuturesExchange> = t.TypeOf<typeof ExchangeFuturesTypes.DataTypes[C][E]['data']>;
}
export declare type FuturesExchange = 'kraken' | 'bitmex';
export declare class ExchangeFuturesTypes {
    static DataTypes: {
        trades: {
            kraken: {
                data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
                    tradeTime: t.RefinementC<t.NumberC>;
                    marketMaker: t.BooleanC;
                    price: t.NumberC;
                    quantity: t.BrandC<t.NumberC, t.IntBrand>;
                }>, t.PartialC<{
                    maturationTime: t.RefinementC<t.NumberC>;
                }>]>, t.TypeC<{
                    symbol: t.KeyofC<{
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                    }>;
                }>, t.PartialC<{
                    reason: t.KeyofC<{
                        fill: t.NullC;
                        liquidation: t.NullC;
                        termination: t.StringC;
                    }>;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
                    tradeTime: t.RefinementC<t.NumberC>;
                    marketMaker: t.BooleanC;
                    price: t.NumberC;
                    quantity: t.BrandC<t.NumberC, t.IntBrand>;
                }>, t.PartialC<{
                    maturationTime: t.RefinementC<t.NumberC>;
                }>]>, t.TypeC<{
                    symbol: t.KeyofC<{
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                    }>;
                }>, t.PartialC<{
                    reason: t.KeyofC<{
                        fill: t.NullC;
                        liquidation: t.NullC;
                        termination: t.StringC;
                    }>;
                }>]>>;
            };
            bitmex: {
                data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
                    tradeTime: t.RefinementC<t.NumberC>;
                    marketMaker: t.BooleanC;
                    price: t.NumberC;
                    quantity: t.BrandC<t.NumberC, t.IntBrand>;
                }>, t.PartialC<{
                    maturationTime: t.RefinementC<t.NumberC>;
                }>]>, t.TypeC<{
                    symbol: t.KeyofC<{
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                        ETHBTC: t.NullC;
                    }>;
                    tradeId: import("io-ts-types").uuidC;
                    grossValue: t.RefinementC<t.NumberC>;
                    homeNotional: t.NumberC;
                    foreignNotional: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
                    tradeTime: t.RefinementC<t.NumberC>;
                    marketMaker: t.BooleanC;
                    price: t.NumberC;
                    quantity: t.BrandC<t.NumberC, t.IntBrand>;
                }>, t.PartialC<{
                    maturationTime: t.RefinementC<t.NumberC>;
                }>]>, t.TypeC<{
                    symbol: t.KeyofC<{
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                        ETHBTC: t.NullC;
                    }>;
                    tradeId: import("io-ts-types").uuidC;
                    grossValue: t.RefinementC<t.NumberC>;
                    homeNotional: t.NumberC;
                    foreignNotional: t.NumberC;
                }>]>>;
            };
        };
        books: {
            kraken: {
                data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
                    price: t.NumberC;
                    maturation: t.RefinementC<t.NumberC>;
                }>]>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    symbol: t.KeyofC<{
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                    }>;
                    quantityTotal: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
                    price: t.NumberC;
                    maturation: t.RefinementC<t.NumberC>;
                }>]>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    symbol: t.KeyofC<{
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                    }>;
                    quantityTotal: t.NumberC;
                }>]>>;
            };
            bitmex: {
                data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
                    price: t.NumberC;
                    maturation: t.RefinementC<t.NumberC>;
                }>]>, t.TypeC<{
                    symbol: t.KeyofC<{
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                        ETHBTC: t.NullC;
                    }>;
                    orderId: t.RefinementC<t.NumberC>;
                    quantityChange: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
                    price: t.NumberC;
                    maturation: t.RefinementC<t.NumberC>;
                }>]>, t.TypeC<{
                    symbol: t.KeyofC<{
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                        ETHBTC: t.NullC;
                    }>;
                    orderId: t.RefinementC<t.NumberC>;
                    quantityChange: t.NumberC;
                }>]>>;
            };
        };
        tickers: {
            kraken: {
                data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
                    ask: t.NumberC;
                    bid: t.NumberC;
                    eventTime: t.RefinementC<t.NumberC>;
                    index: t.NumberC;
                    last: t.NumberC;
                    leverage: t.StringC;
                    maturationInterval: t.KeyofC<{
                        perpetual: t.NullC;
                        monthly: t.NullC;
                        quarterly: t.NullC;
                        biquarterly: t.NullC;
                    }>;
                    markPrice: t.NumberC;
                    openInterest: t.NumberC;
                    priceChange: t.NumberC;
                    volume: t.NumberC;
                }>, t.PartialC<{
                    maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
                    nextFundingRateTime: t.NumberC;
                    fundingRate: t.NumberC;
                    fundingRatePrediction: t.NumberC;
                }>]>, t.TypeC<{
                    askSize: t.NumberC;
                    bidSize: t.NumberC;
                    premium: t.NumberC;
                    symbol: t.KeyofC<{
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                    }>;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
                    ask: t.NumberC;
                    bid: t.NumberC;
                    eventTime: t.RefinementC<t.NumberC>;
                    index: t.NumberC;
                    last: t.NumberC;
                    leverage: t.StringC;
                    maturationInterval: t.KeyofC<{
                        perpetual: t.NullC;
                        monthly: t.NullC;
                        quarterly: t.NullC;
                        biquarterly: t.NullC;
                    }>;
                    markPrice: t.NumberC;
                    openInterest: t.NumberC;
                    priceChange: t.NumberC;
                    volume: t.NumberC;
                }>, t.PartialC<{
                    maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
                    nextFundingRateTime: t.NumberC;
                    fundingRate: t.NumberC;
                    fundingRatePrediction: t.NumberC;
                }>]>, t.TypeC<{
                    askSize: t.NumberC;
                    bidSize: t.NumberC;
                    premium: t.NumberC;
                    symbol: t.KeyofC<{
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                    }>;
                }>]>>;
            };
            bitmex: {
                data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
                    ask: t.NumberC;
                    bid: t.NumberC;
                    eventTime: t.RefinementC<t.NumberC>;
                    index: t.NumberC;
                    last: t.NumberC;
                    leverage: t.StringC;
                    maturationInterval: t.KeyofC<{
                        perpetual: t.NullC;
                        monthly: t.NullC;
                        quarterly: t.NullC;
                        biquarterly: t.NullC;
                    }>;
                    markPrice: t.NumberC;
                    openInterest: t.NumberC;
                    priceChange: t.NumberC;
                    volume: t.NumberC;
                }>, t.PartialC<{
                    maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
                    nextFundingRateTime: t.NumberC;
                    fundingRate: t.NumberC;
                    fundingRatePrediction: t.NumberC;
                }>]>, t.TypeC<{
                    symbol: t.KeyofC<{
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                        ETHBTC: t.NullC;
                    }>;
                    low: t.NumberC;
                    high: t.NumberC;
                    volWeightedAvePrice: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
                    ask: t.NumberC;
                    bid: t.NumberC;
                    eventTime: t.RefinementC<t.NumberC>;
                    index: t.NumberC;
                    last: t.NumberC;
                    leverage: t.StringC;
                    maturationInterval: t.KeyofC<{
                        perpetual: t.NullC;
                        monthly: t.NullC;
                        quarterly: t.NullC;
                        biquarterly: t.NullC;
                    }>;
                    markPrice: t.NumberC;
                    openInterest: t.NumberC;
                    priceChange: t.NumberC;
                    volume: t.NumberC;
                }>, t.PartialC<{
                    maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
                    nextFundingRateTime: t.NumberC;
                    fundingRate: t.NumberC;
                    fundingRatePrediction: t.NumberC;
                }>]>, t.TypeC<{
                    symbol: t.KeyofC<{
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                        ETHBTC: t.NullC;
                    }>;
                    low: t.NumberC;
                    high: t.NumberC;
                    volWeightedAvePrice: t.NumberC;
                }>]>>;
            };
        };
    };
    static Exchange: t.KeyofC<{
        kraken: t.NullC;
    }>;
    static Interval: t.KeyofC<{
        monthly: null;
        quarterly: null;
        perpetual: null;
    }>;
    static ALL_EXCHANGE_FUTURES_TYPES: never[];
}
