import * as t from 'io-ts';
import WebSocket from 'ws';
import { BitcoinNetwork, LightningApi } from '../../lightning';
import { FuturesExchange } from '../../types/exchange/futures';
import { SpotExchange } from '../../types/exchange/spot';
import { Omit } from '../../types/util';
import { AtleastUUID, OnWsOpen, SbWebSocket } from '../common';
export declare type CryptoAPI = 'futures' | 'spot';
export declare type Exchange = SpotExchange | FuturesExchange;
export declare type ExchangeChannel = 'tickers' | 'trades' | 'books';
export declare type NoChannel<T> = Omit<T, 'channel'>;
export declare type TestnetArgs<T> = Omit<T, 'symbol'>;
export interface Subscription {
    refill: (addedDuration: number) => Promise<any>;
    unsubscribe: () => Promise<any>;
}
/**
 * Common interface for spot and futures
 * subscription arguments
 */
export interface BaseSubscribeArgs<E extends Exchange, C extends ExchangeChannel> {
    /**
     * Duration of subscription, in **milliseconds**
     */
    duration: number;
    /**
     * If refundInvoice is not supplied, we ask your LN client
     * to generate one.
     */
    refundInvoice?: string;
    /**
     * Which trading symbol (currency pair) to
     * subscribe to
     */
    symbol: any;
    /**
     *
     * Which exchange to subscribe to
     */
    exchange: E;
    /**
     * Which channel to subscribe to
     */
    channel: C;
    /**
     * Callback that gets executed when a subscription is ended.
     * The argument that gets passed into this function is a list
     * of all previously collected data points.
     */
    onSubscriptionEnded?: (datapoint: any[]) => any;
    /**
     * Callback that gets executed when the *snapshot* is received.
     * A snapshot in this context is the pre-existing date that's
     * neeeded to follow along the updates that's happening on a
     * given exchange. If you're subscribing to book updates, for
     * example, you'd use the snapshot to initialize your view
     * of the order book, and then use the received updates to
     * keep your view of the book in sync with what's happening
     * on the exchange.
     */
    onSnapshot: (snapshot: any) => any;
    /**
     * Callback that gets executed when a data point is received.
     */
    onData: (data: any) => any;
}
export declare abstract class ExchangeSocketBase extends SbWebSocket {
    protected ln: LightningApi;
    constructor(ln: LightningApi, network: BitcoinNetwork, cryptoApi: CryptoAPI, onOpen: OnWsOpen);
    /**
     * CB that gets invoked when a refill request is being made
     */
    private handleRefill;
    /**
     * CB that gets invoked when a unsubscribe request is being made
     */
    private handleUnsubscribe;
    /**
     * CB that gets invoked when a new message is received
     * over the WS
     */
    protected handleMessage: (uuid: string, parsed: AtleastUUID, wsData: WebSocket.Data) => Promise<void>;
    /**
     * Adds a received data point from the API to the list of data points
     * that is passed into the final callback
     */
    private addDataPoint;
    private onSnapshotValidationError;
    private onDataValidationError;
    protected abstract getTypes(channel: ExchangeChannel, exchange: Exchange): {
        data: t.Type<any>;
        snapshot: t.Type<any>;
    };
    /**
     * Should throw if the given exchange does not support the given channel
     */
    protected abstract checkChannelAndExchange(channel: ExchangeChannel, exchange: Exchange): void;
    protected subscribe: <E extends "kraken" | "bitmex" | "coinbase" | "binance" | "bitfinex" | "gemini" | "bitstamp", C extends ExchangeChannel, SubArgs extends BaseSubscribeArgs<E, C>>({ symbol, refundInvoice, channel, exchange, onData, onSnapshot, onSubscriptionEnded, duration, ...rest }: SubArgs) => Promise<Subscription>;
    private subscriptions;
}
