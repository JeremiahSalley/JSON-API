import * as t from 'io-ts';
import { LightningApi } from '../../lightning';
import { FuturesExchangeSymbols } from '../../types/exchange/common/symbols';
import { ExchangeFuturesTypes, FuturesExchange } from '../../types/exchange/futures';
import { OnWsOpen } from '../common';
import { BaseSubscribeArgs, ExchangeChannel, ExchangeSocketBase, Subscription } from './common';
export declare type ExchangeFuturesChannel = 'tickers' | 'trades' | 'books';
export declare type MaturationInterval = KrakenMaturationInterval | BitmexMaturationInterval;
export declare type MaturationIntervalForExchangeAndSymbol<E extends FuturesExchange, S extends FuturesExchangeSymbols<E>> = E extends 'kraken' ? KrakenMaturationInterval : E extends 'bitmex' ? S extends 'BTCUSD' ? BitmexMaturationIntervalBTCUSD : S extends 'ETHUSD' ? BitmexMaturationIntervalETHUSD : S extends 'ETHBTC' ? BitmexMaturationIntervalETHBTC : never : never;
export declare const KrakenMaturationInterval: t.KeyofC<{
    monthly: t.NullC;
    quarterly: t.NullC;
    perpetual: t.NullC;
}>;
export declare type KrakenMaturationInterval = t.TypeOf<typeof KrakenMaturationInterval>;
export declare const BitmexMaturationIntervalBTCUSD: t.KeyofC<{
    quarterly: t.NullC;
    perpetual: t.NullC;
    biquarterly: t.NullC;
}>;
export declare type BitmexMaturationIntervalBTCUSD = t.TypeOf<typeof BitmexMaturationIntervalBTCUSD>;
export declare const BitmexMaturationIntervalETHUSD: t.KeyofC<{
    perpetual: t.NullC;
}>;
export declare type BitmexMaturationIntervalETHUSD = t.TypeOf<typeof BitmexMaturationIntervalETHUSD>;
export declare const BitmexMaturationIntervalETHBTC: t.KeyofC<{
    monthly: t.NullC;
}>;
export declare type BitmexMaturationIntervalETHBTC = t.TypeOf<typeof BitmexMaturationIntervalETHBTC>;
export declare type BitmexMaturationInterval = BitmexMaturationIntervalBTCUSD | BitmexMaturationIntervalETHBTC | BitmexMaturationIntervalETHUSD;
export interface FuturesSubscribeArgs<E extends FuturesExchange, C extends ExchangeChannel, S extends FuturesExchangeSymbols<E>> extends BaseSubscribeArgs<E, C> {
    /**
     * The maturation interval of the futures market you're requesting data about
     *
     * Defaults to __perpetual__.
     */
    interval?: MaturationIntervalForExchangeAndSymbol<E, S>;
    symbol: S;
    onSnapshot: (snapshot: ExchangeFuturesTypes.FuturesSnapshot<C, E>) => any;
    onData: (data: ExchangeFuturesTypes.FuturesData<C, E>) => any;
    onSubscriptionEnded?: (datapoint: Array<ExchangeFuturesTypes.FuturesData<C, E>>) => any;
}
export declare class ExchangeFuturesSocket extends ExchangeSocketBase {
    protected ln: LightningApi;
    constructor(ln: LightningApi, onOpen: OnWsOpen);
    protected checkChannelAndExchange: (channel: ExchangeChannel, exchange: "kraken" | "bitmex" | "coinbase" | "binance" | "bitfinex" | "gemini" | "bitstamp") => void;
    protected getTypes: (channel: ExchangeChannel, exchange: FuturesExchange) => {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
            price: t.NumberC;
            maturation: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            eventTime: t.RefinementC<t.NumberC>;
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
            quantityTotal: t.NumberC;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
            price: t.NumberC;
            maturation: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            eventTime: t.RefinementC<t.NumberC>;
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
            quantityTotal: t.NumberC;
        }>]>>;
    } | {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
            price: t.NumberC;
            maturation: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            orderId: t.RefinementC<t.NumberC>;
            quantityChange: t.NumberC;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
            price: t.NumberC;
            maturation: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            orderId: t.RefinementC<t.NumberC>;
            quantityChange: t.NumberC;
        }>]>>;
    } | {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            ask: t.NumberC;
            bid: t.NumberC;
            eventTime: t.RefinementC<t.NumberC>;
            index: t.NumberC;
            last: t.NumberC;
            leverage: t.StringC;
            maturationInterval: t.KeyofC<{
                perpetual: t.NullC;
                monthly: t.NullC;
                quarterly: t.NullC;
                biquarterly: t.NullC;
            }>;
            markPrice: t.NumberC;
            openInterest: t.NumberC;
            priceChange: t.NumberC;
            volume: t.NumberC;
        }>, t.PartialC<{
            maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
            nextFundingRateTime: t.NumberC;
            fundingRate: t.NumberC;
            fundingRatePrediction: t.NumberC;
        }>]>, t.TypeC<{
            askSize: t.NumberC;
            bidSize: t.NumberC;
            premium: t.NumberC;
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            ask: t.NumberC;
            bid: t.NumberC;
            eventTime: t.RefinementC<t.NumberC>;
            index: t.NumberC;
            last: t.NumberC;
            leverage: t.StringC;
            maturationInterval: t.KeyofC<{
                perpetual: t.NullC;
                monthly: t.NullC;
                quarterly: t.NullC;
                biquarterly: t.NullC;
            }>;
            markPrice: t.NumberC;
            openInterest: t.NumberC;
            priceChange: t.NumberC;
            volume: t.NumberC;
        }>, t.PartialC<{
            maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
            nextFundingRateTime: t.NumberC;
            fundingRate: t.NumberC;
            fundingRatePrediction: t.NumberC;
        }>]>, t.TypeC<{
            askSize: t.NumberC;
            bidSize: t.NumberC;
            premium: t.NumberC;
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
        }>]>>;
    } | {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            ask: t.NumberC;
            bid: t.NumberC;
            eventTime: t.RefinementC<t.NumberC>;
            index: t.NumberC;
            last: t.NumberC;
            leverage: t.StringC;
            maturationInterval: t.KeyofC<{
                perpetual: t.NullC;
                monthly: t.NullC;
                quarterly: t.NullC;
                biquarterly: t.NullC;
            }>;
            markPrice: t.NumberC;
            openInterest: t.NumberC;
            priceChange: t.NumberC;
            volume: t.NumberC;
        }>, t.PartialC<{
            maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
            nextFundingRateTime: t.NumberC;
            fundingRate: t.NumberC;
            fundingRatePrediction: t.NumberC;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            low: t.NumberC;
            high: t.NumberC;
            volWeightedAvePrice: t.NumberC;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            ask: t.NumberC;
            bid: t.NumberC;
            eventTime: t.RefinementC<t.NumberC>;
            index: t.NumberC;
            last: t.NumberC;
            leverage: t.StringC;
            maturationInterval: t.KeyofC<{
                perpetual: t.NullC;
                monthly: t.NullC;
                quarterly: t.NullC;
                biquarterly: t.NullC;
            }>;
            markPrice: t.NumberC;
            openInterest: t.NumberC;
            priceChange: t.NumberC;
            volume: t.NumberC;
        }>, t.PartialC<{
            maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
            nextFundingRateTime: t.NumberC;
            fundingRate: t.NumberC;
            fundingRatePrediction: t.NumberC;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            low: t.NumberC;
            high: t.NumberC;
            volWeightedAvePrice: t.NumberC;
        }>]>>;
    } | {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            tradeTime: t.RefinementC<t.NumberC>;
            marketMaker: t.BooleanC;
            price: t.NumberC;
            quantity: t.BrandC<t.NumberC, t.IntBrand>;
        }>, t.PartialC<{
            maturationTime: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
        }>, t.PartialC<{
            reason: t.KeyofC<{
                fill: t.NullC;
                liquidation: t.NullC;
                termination: t.StringC;
            }>;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            tradeTime: t.RefinementC<t.NumberC>;
            marketMaker: t.BooleanC;
            price: t.NumberC;
            quantity: t.BrandC<t.NumberC, t.IntBrand>;
        }>, t.PartialC<{
            maturationTime: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
        }>, t.PartialC<{
            reason: t.KeyofC<{
                fill: t.NullC;
                liquidation: t.NullC;
                termination: t.StringC;
            }>;
        }>]>>;
    } | {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            tradeTime: t.RefinementC<t.NumberC>;
            marketMaker: t.BooleanC;
            price: t.NumberC;
            quantity: t.BrandC<t.NumberC, t.IntBrand>;
        }>, t.PartialC<{
            maturationTime: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            tradeId: import("io-ts-types").uuidC;
            grossValue: t.RefinementC<t.NumberC>;
            homeNotional: t.NumberC;
            foreignNotional: t.NumberC;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            tradeTime: t.RefinementC<t.NumberC>;
            marketMaker: t.BooleanC;
            price: t.NumberC;
            quantity: t.BrandC<t.NumberC, t.IntBrand>;
        }>, t.PartialC<{
            maturationTime: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            tradeId: import("io-ts-types").uuidC;
            grossValue: t.RefinementC<t.NumberC>;
            homeNotional: t.NumberC;
            foreignNotional: t.NumberC;
        }>]>>;
    };
    tickers: <E extends FuturesExchange, S extends FuturesExchangeSymbols<E>>(args: Pick<FuturesSubscribeArgs<E, "tickers", S>, "symbol" | "refundInvoice" | "exchange" | "onData" | "onSnapshot" | "onSubscriptionEnded" | "duration" | "interval">) => Promise<Subscription>;
    books: <E extends FuturesExchange, S extends FuturesExchangeSymbols<E>>(args: Pick<FuturesSubscribeArgs<E, "books", S>, "symbol" | "refundInvoice" | "exchange" | "onData" | "onSnapshot" | "onSubscriptionEnded" | "duration" | "interval">) => Promise<Subscription>;
    trades: <E extends FuturesExchange, S extends FuturesExchangeSymbols<E>>(args: Pick<FuturesSubscribeArgs<E, "trades", S>, "symbol" | "refundInvoice" | "exchange" | "onData" | "onSnapshot" | "onSubscriptionEnded" | "duration" | "interval">) => Promise<Subscription>;
}
export declare class ExchangeFuturesSocketTestnet extends ExchangeSocketBase {
    protected ln: LightningApi;
    constructor(ln: LightningApi, onOpen: OnWsOpen);
    protected checkChannelAndExchange: (channel: ExchangeChannel, exchange: "kraken" | "bitmex" | "coinbase" | "binance" | "bitfinex" | "gemini" | "bitstamp") => void;
    private doesExchangeSupportFutures;
    protected getTypes: (channel: ExchangeChannel, exchange: FuturesExchange) => {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
            price: t.NumberC;
            maturation: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            eventTime: t.RefinementC<t.NumberC>;
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
            quantityTotal: t.NumberC;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
            price: t.NumberC;
            maturation: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            eventTime: t.RefinementC<t.NumberC>;
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
            quantityTotal: t.NumberC;
        }>]>>;
    } | {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
            price: t.NumberC;
            maturation: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            orderId: t.RefinementC<t.NumberC>;
            quantityChange: t.NumberC;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{}>, t.PartialC<{
            price: t.NumberC;
            maturation: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            orderId: t.RefinementC<t.NumberC>;
            quantityChange: t.NumberC;
        }>]>>;
    } | {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            ask: t.NumberC;
            bid: t.NumberC;
            eventTime: t.RefinementC<t.NumberC>;
            index: t.NumberC;
            last: t.NumberC;
            leverage: t.StringC;
            maturationInterval: t.KeyofC<{
                perpetual: t.NullC;
                monthly: t.NullC;
                quarterly: t.NullC;
                biquarterly: t.NullC;
            }>;
            markPrice: t.NumberC;
            openInterest: t.NumberC;
            priceChange: t.NumberC;
            volume: t.NumberC;
        }>, t.PartialC<{
            maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
            nextFundingRateTime: t.NumberC;
            fundingRate: t.NumberC;
            fundingRatePrediction: t.NumberC;
        }>]>, t.TypeC<{
            askSize: t.NumberC;
            bidSize: t.NumberC;
            premium: t.NumberC;
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            ask: t.NumberC;
            bid: t.NumberC;
            eventTime: t.RefinementC<t.NumberC>;
            index: t.NumberC;
            last: t.NumberC;
            leverage: t.StringC;
            maturationInterval: t.KeyofC<{
                perpetual: t.NullC;
                monthly: t.NullC;
                quarterly: t.NullC;
                biquarterly: t.NullC;
            }>;
            markPrice: t.NumberC;
            openInterest: t.NumberC;
            priceChange: t.NumberC;
            volume: t.NumberC;
        }>, t.PartialC<{
            maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
            nextFundingRateTime: t.NumberC;
            fundingRate: t.NumberC;
            fundingRatePrediction: t.NumberC;
        }>]>, t.TypeC<{
            askSize: t.NumberC;
            bidSize: t.NumberC;
            premium: t.NumberC;
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
        }>]>>;
    } | {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            ask: t.NumberC;
            bid: t.NumberC;
            eventTime: t.RefinementC<t.NumberC>;
            index: t.NumberC;
            last: t.NumberC;
            leverage: t.StringC;
            maturationInterval: t.KeyofC<{
                perpetual: t.NullC;
                monthly: t.NullC;
                quarterly: t.NullC;
                biquarterly: t.NullC;
            }>;
            markPrice: t.NumberC;
            openInterest: t.NumberC;
            priceChange: t.NumberC;
            volume: t.NumberC;
        }>, t.PartialC<{
            maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
            nextFundingRateTime: t.NumberC;
            fundingRate: t.NumberC;
            fundingRatePrediction: t.NumberC;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            low: t.NumberC;
            high: t.NumberC;
            volWeightedAvePrice: t.NumberC;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            ask: t.NumberC;
            bid: t.NumberC;
            eventTime: t.RefinementC<t.NumberC>;
            index: t.NumberC;
            last: t.NumberC;
            leverage: t.StringC;
            maturationInterval: t.KeyofC<{
                perpetual: t.NullC;
                monthly: t.NullC;
                quarterly: t.NullC;
                biquarterly: t.NullC;
            }>;
            markPrice: t.NumberC;
            openInterest: t.NumberC;
            priceChange: t.NumberC;
            volume: t.NumberC;
        }>, t.PartialC<{
            maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
            nextFundingRateTime: t.NumberC;
            fundingRate: t.NumberC;
            fundingRatePrediction: t.NumberC;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            low: t.NumberC;
            high: t.NumberC;
            volWeightedAvePrice: t.NumberC;
        }>]>>;
    } | {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            tradeTime: t.RefinementC<t.NumberC>;
            marketMaker: t.BooleanC;
            price: t.NumberC;
            quantity: t.BrandC<t.NumberC, t.IntBrand>;
        }>, t.PartialC<{
            maturationTime: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
        }>, t.PartialC<{
            reason: t.KeyofC<{
                fill: t.NullC;
                liquidation: t.NullC;
                termination: t.StringC;
            }>;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            tradeTime: t.RefinementC<t.NumberC>;
            marketMaker: t.BooleanC;
            price: t.NumberC;
            quantity: t.BrandC<t.NumberC, t.IntBrand>;
        }>, t.PartialC<{
            maturationTime: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
        }>, t.PartialC<{
            reason: t.KeyofC<{
                fill: t.NullC;
                liquidation: t.NullC;
                termination: t.StringC;
            }>;
        }>]>>;
    } | {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            tradeTime: t.RefinementC<t.NumberC>;
            marketMaker: t.BooleanC;
            price: t.NumberC;
            quantity: t.BrandC<t.NumberC, t.IntBrand>;
        }>, t.PartialC<{
            maturationTime: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            tradeId: import("io-ts-types").uuidC;
            grossValue: t.RefinementC<t.NumberC>;
            homeNotional: t.NumberC;
            foreignNotional: t.NumberC;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            tradeTime: t.RefinementC<t.NumberC>;
            marketMaker: t.BooleanC;
            price: t.NumberC;
            quantity: t.BrandC<t.NumberC, t.IntBrand>;
        }>, t.PartialC<{
            maturationTime: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            tradeId: import("io-ts-types").uuidC;
            grossValue: t.RefinementC<t.NumberC>;
            homeNotional: t.NumberC;
            foreignNotional: t.NumberC;
        }>]>>;
    };
    tickers: <E extends FuturesExchange>(args: Pick<Pick<FuturesSubscribeArgs<E, "tickers", any>, "symbol" | "refundInvoice" | "exchange" | "onData" | "onSnapshot" | "onSubscriptionEnded" | "duration" | "interval">, "refundInvoice" | "exchange" | "onData" | "onSnapshot" | "onSubscriptionEnded" | "duration" | "interval">) => Promise<Subscription>;
    books: <E extends FuturesExchange>(args: Pick<Pick<FuturesSubscribeArgs<E, "books", any>, "symbol" | "refundInvoice" | "exchange" | "onData" | "onSnapshot" | "onSubscriptionEnded" | "duration" | "interval">, "refundInvoice" | "exchange" | "onData" | "onSnapshot" | "onSubscriptionEnded" | "duration" | "interval">) => Promise<Subscription>;
    trades: <E extends FuturesExchange>(args: Pick<Pick<FuturesSubscribeArgs<E, "trades", any>, "symbol" | "refundInvoice" | "exchange" | "onData" | "onSnapshot" | "onSubscriptionEnded" | "duration" | "interval">, "refundInvoice" | "exchange" | "onData" | "onSnapshot" | "onSubscriptionEnded" | "duration" | "interval">) => Promise<Subscription>;
}
