import * as t from 'io-ts';
import { ExchangeChannel } from '../../../sockets/crypto/common';
export declare namespace ExchangeSpotTypes {
    type SpotSnapshot<C extends ExchangeChannel, E extends SpotExchange> = t.TypeOf<typeof ExchangeSpotTypes.DataTypes[C][E]['snapshot']>;
    type SpotData<C extends ExchangeChannel, E extends SpotExchange> = t.TypeOf<typeof ExchangeSpotTypes.DataTypes[C][E]['data']>;
}
export declare type SpotExchange = t.TypeOf<typeof ExchangeSpotTypes.Exchange>;
export declare class ExchangeSpotTypes {
    static DataTypes: {
        trades: {
            bitfinex: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                    quantity: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    tradeId: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                    quantity: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    tradeId: t.NumberC;
                }>]>>;
            };
            coinbase: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                    quantity: t.NumberC;
                }>, t.TypeC<{
                    buyerId: t.StringC;
                    marketMaker: t.BooleanC;
                    sellerId: t.StringC;
                    symbol: t.StringC;
                    tradeId: t.NumberC;
                    tradeTime: t.RefinementC<t.NumberC>;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                    quantity: t.NumberC;
                }>, t.TypeC<{
                    buyerId: t.StringC;
                    marketMaker: t.BooleanC;
                    sellerId: t.StringC;
                    symbol: t.StringC;
                    tradeId: t.NumberC;
                    tradeTime: t.RefinementC<t.NumberC>;
                }>]>>;
            };
            binance: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                    quantity: t.NumberC;
                }>, t.TypeC<{
                    buyerId: t.StringC;
                    eventTime: t.RefinementC<t.NumberC>;
                    marketMaker: t.BooleanC;
                    sellerId: t.StringC;
                    symbol: t.StringC;
                    tradeId: t.NumberC;
                    tradeTime: t.RefinementC<t.NumberC>;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                    quantity: t.NumberC;
                }>, t.TypeC<{
                    buyerId: t.StringC;
                    eventTime: t.RefinementC<t.NumberC>;
                    marketMaker: t.BooleanC;
                    sellerId: t.StringC;
                    symbol: t.StringC;
                    tradeId: t.NumberC;
                    tradeTime: t.RefinementC<t.NumberC>;
                }>]>>;
            };
            gemini: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                    quantity: t.NumberC;
                }>, t.TypeC<{
                    marketMaker: t.BooleanC;
                    tradeId: t.NumberC;
                    tradeTime: t.RefinementC<t.NumberC>;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                    quantity: t.NumberC;
                }>, t.TypeC<{
                    marketMaker: t.BooleanC;
                    tradeId: t.NumberC;
                    tradeTime: t.RefinementC<t.NumberC>;
                }>]>>;
            };
            bitstamp: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                    quantity: t.NumberC;
                }>, t.TypeC<{
                    buyerId: t.StringC;
                    marketMaker: t.BooleanC;
                    sellerId: t.StringC;
                    tradeId: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                    quantity: t.NumberC;
                }>, t.TypeC<{
                    buyerId: t.StringC;
                    marketMaker: t.BooleanC;
                    sellerId: t.StringC;
                    tradeId: t.NumberC;
                }>]>>;
            };
            kraken: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                    quantity: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    marketMaker: t.BooleanC;
                    symbol: t.StringC;
                    tradeTime: t.RefinementC<t.NumberC>;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                    quantity: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    marketMaker: t.BooleanC;
                    symbol: t.StringC;
                    tradeTime: t.RefinementC<t.NumberC>;
                }>]>>;
            };
            bitmex: {
                data: t.TypeC<{}>;
                snapshot: t.ArrayC<t.TypeC<{}>>;
            };
        };
        books: {
            bitfinex: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.NumberC;
                    orderId: t.NumberC;
                    quantityTotal: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.NumberC;
                    orderId: t.NumberC;
                    quantityTotal: t.NumberC;
                }>]>>;
            };
            binance: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    quantityTotal: t.NumberC;
                    symbol: t.KeyofC<{
                        BTCUSDT: t.NullC;
                        ETHBTC: t.NullC;
                        ETHUSDT: t.NullC;
                    }>;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    quantityTotal: t.NumberC;
                    symbol: t.KeyofC<{
                        BTCUSDT: t.NullC;
                        ETHBTC: t.NullC;
                        ETHUSDT: t.NullC;
                    }>;
                }>]>>;
            };
            coinbase: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                }>, t.TypeC<{
                    symbol: t.KeyofC<{
                        ETHBTC: t.NullC;
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                    }>;
                    quantityTotal: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                }>, t.TypeC<{
                    symbol: t.KeyofC<{
                        ETHBTC: t.NullC;
                        BTCUSD: t.NullC;
                        ETHUSD: t.NullC;
                    }>;
                    quantityTotal: t.NumberC;
                }>]>>;
            };
            gemini: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    quantityChange: t.NumberC;
                    quantityTotal: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    quantityChange: t.NumberC;
                    quantityTotal: t.NumberC;
                }>]>>;
            };
            bitstamp: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    orderId: t.RefinementC<t.NumberC>;
                    quantityChange: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    price: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    orderId: t.RefinementC<t.NumberC>;
                    quantityChange: t.NumberC;
                }>]>>;
            };
            kraken: {
                data: t.RefinementC<t.TypeC<{}>>;
                snapshot: t.ArrayC<t.TypeC<{}>>;
            };
            bitmex: {
                data: t.TypeC<{}>;
                snapshot: t.ArrayC<t.TypeC<{}>>;
            };
        };
        tickers: {
            binance: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    bid: t.NumberC;
                    ask: t.NumberC;
                    symbol: t.StringC;
                    volume: t.NumberC;
                }>, t.TypeC<{
                    askSize: t.NumberC;
                    bidSize: t.NumberC;
                    close: t.NumberC;
                    closeQuantity: t.NumberC;
                    eventTime: t.RefinementC<t.NumberC>;
                    firstTradeId: t.RefinementC<t.NumberC>;
                    high: t.NumberC;
                    lastTradeId: t.RefinementC<t.NumberC>;
                    low: t.NumberC;
                    open: t.NumberC;
                    prevClose: t.NumberC;
                    priceChange: t.NumberC;
                    priceChangePerc: t.NumberC;
                    quoteVolume: t.NumberC;
                    statCloseTime: t.NumberC;
                    statOpenTime: t.NumberC;
                    weightedAvePrice: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    bid: t.NumberC;
                    ask: t.NumberC;
                    symbol: t.StringC;
                    volume: t.NumberC;
                }>, t.TypeC<{
                    askSize: t.NumberC;
                    bidSize: t.NumberC;
                    close: t.NumberC;
                    closeQuantity: t.NumberC;
                    eventTime: t.RefinementC<t.NumberC>;
                    firstTradeId: t.RefinementC<t.NumberC>;
                    high: t.NumberC;
                    lastTradeId: t.RefinementC<t.NumberC>;
                    low: t.NumberC;
                    open: t.NumberC;
                    prevClose: t.NumberC;
                    priceChange: t.NumberC;
                    priceChangePerc: t.NumberC;
                    quoteVolume: t.NumberC;
                    statCloseTime: t.NumberC;
                    statOpenTime: t.NumberC;
                    weightedAvePrice: t.NumberC;
                }>]>>;
            };
            bitfinex: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    bid: t.NumberC;
                    ask: t.NumberC;
                    symbol: t.StringC;
                    volume: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    priceChange: t.NumberC;
                    priceChangePerc: t.NumberC;
                    close: t.NumberC;
                    bidSize: t.NumberC;
                    askSize: t.NumberC;
                    high: t.NumberC;
                    low: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    bid: t.NumberC;
                    ask: t.NumberC;
                    symbol: t.StringC;
                    volume: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    priceChange: t.NumberC;
                    priceChangePerc: t.NumberC;
                    close: t.NumberC;
                    bidSize: t.NumberC;
                    askSize: t.NumberC;
                    high: t.NumberC;
                    low: t.NumberC;
                }>]>>;
            };
            coinbase: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    bid: t.NumberC;
                    ask: t.NumberC;
                    symbol: t.StringC;
                    volume: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    open: t.NumberC;
                    high: t.NumberC;
                    low: t.NumberC;
                    lastTradeId: t.RefinementC<t.NumberC>;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    bid: t.NumberC;
                    ask: t.NumberC;
                    symbol: t.StringC;
                    volume: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    open: t.NumberC;
                    high: t.NumberC;
                    low: t.NumberC;
                    lastTradeId: t.RefinementC<t.NumberC>;
                }>]>>;
            };
            gemini: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    bid: t.NumberC;
                    ask: t.NumberC;
                    symbol: t.StringC;
                    volume: t.NumberC;
                }>, t.TypeC<{
                    statCloseTime: t.RefinementC<t.NumberC>;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    bid: t.NumberC;
                    ask: t.NumberC;
                    symbol: t.StringC;
                    volume: t.NumberC;
                }>, t.TypeC<{
                    statCloseTime: t.RefinementC<t.NumberC>;
                }>]>>;
            };
            bitstamp: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    bid: t.NumberC;
                    ask: t.NumberC;
                    symbol: t.StringC;
                    volume: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    weightedAvePrice: t.NumberC;
                    ask: t.NumberC;
                    open: t.NumberC;
                    high: t.NumberC;
                    low: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    bid: t.NumberC;
                    ask: t.NumberC;
                    symbol: t.StringC;
                    volume: t.NumberC;
                }>, t.TypeC<{
                    eventTime: t.RefinementC<t.NumberC>;
                    weightedAvePrice: t.NumberC;
                    ask: t.NumberC;
                    open: t.NumberC;
                    high: t.NumberC;
                    low: t.NumberC;
                }>]>>;
            };
            kraken: {
                data: t.RefinementC<t.IntersectionC<[t.TypeC<{
                    bid: t.NumberC;
                    ask: t.NumberC;
                    symbol: t.StringC;
                    volume: t.NumberC;
                }>, t.TypeC<{
                    askSize: t.NumberC;
                    bidSize: t.NumberC;
                    close: t.NumberC;
                    closeQuantity: t.NumberC;
                    eventTime: t.RefinementC<t.NumberC>;
                    high: t.NumberC;
                    low: t.NumberC;
                    open: t.NumberC;
                    statCloseTime: t.NumberC;
                    statOpenTime: t.NumberC;
                    totalTrades: t.RefinementC<t.NumberC>;
                    weightedAvePrice: t.NumberC;
                }>]>>;
                snapshot: t.ArrayC<t.IntersectionC<[t.TypeC<{
                    bid: t.NumberC;
                    ask: t.NumberC;
                    symbol: t.StringC;
                    volume: t.NumberC;
                }>, t.TypeC<{
                    askSize: t.NumberC;
                    bidSize: t.NumberC;
                    close: t.NumberC;
                    closeQuantity: t.NumberC;
                    eventTime: t.RefinementC<t.NumberC>;
                    high: t.NumberC;
                    low: t.NumberC;
                    open: t.NumberC;
                    statCloseTime: t.NumberC;
                    statOpenTime: t.NumberC;
                    totalTrades: t.RefinementC<t.NumberC>;
                    weightedAvePrice: t.NumberC;
                }>]>>;
            };
            bitmex: {
                data: t.TypeC<{}>;
                snapshot: t.ArrayC<t.TypeC<{}>>;
            };
        };
    };
    static Exchange: t.KeyofC<{
        coinbase: t.NullC;
        binance: t.NullC;
        bitfinex: t.NullC;
        gemini: t.NullC;
        bitstamp: t.NullC;
        kraken: t.NullC;
    }>;
}
