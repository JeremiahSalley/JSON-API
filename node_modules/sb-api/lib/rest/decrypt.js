"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_js_1 = __importDefault(require("crypto-js"));
/**
 * Trims any trailing zero bytes from the given
 * word array
 *
 * @param {CryptoJS.WordArray} words
 * @return {CryptoJS.WordArray}
 */
function trimWordArray(words) {
    ;
    words.clamp();
    return words;
}
/**
 * Deserializes the given base64 into IV and
 * ciphertext
 *
 * @returns ciphertext and IV
 */
function deserializeEncrypted(encrypted) {
    var deserialized = crypto_js_1.default.enc.Base64.parse(encrypted);
    var hex = deserialized.toString(crypto_js_1.default.enc.Hex);
    var deserializedIV = crypto_js_1.default.enc.Hex.parse(hex.slice(0, 32) // first 16 bytes are IV
    );
    var deserializedCipherText = crypto_js_1.default.enc.Hex.parse(hex.slice(32)); // rest is cipher text
    return [trimWordArray(deserializedCipherText), deserializedIV];
}
/**
 * @param {string} base64 Base64 encoded IV and ciphertext
 * @param {string} preimage hex string of the preimage
 * @param {string} publicKey hex string of the public key
 */
function decrypt(base64, preimage) {
    var preimageByteLength = preimage.length / 2;
    if ([16, 24, 32].every(function (l) { return preimageByteLength !== l; })) {
        throw new TypeError("The given preimage is " + preimageByteLength + " bytes long! Valid lengths: 16, 24, 32");
    }
    var parsedPreimage = crypto_js_1.default.enc.Hex.parse(preimage);
    var _a = deserializeEncrypted(base64), ciphertext = _a[0], IV = _a[1];
    var decrypted = crypto_js_1.default.AES.decrypt({ ciphertext: ciphertext }, parsedPreimage, {
        mode: crypto_js_1.default.mode.CFB,
        padding: crypto_js_1.default.pad.NoPadding,
        iv: IV,
    });
    return decrypted.toString(crypto_js_1.default.enc.Utf8);
}
exports.decrypt = decrypt;
