"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var debug_1 = __importDefault(require("debug"));
var t = __importStar(require("io-ts"));
var types = __importStar(require("io-ts-types"));
var PathReporter_1 = require("io-ts/lib/PathReporter");
var books_1 = require("./exchange/futures/books");
var tickers_1 = require("./exchange/futures/tickers");
var trades_1 = require("./exchange/futures/trades");
var books_2 = require("./exchange/spot/books");
var tickers_2 = require("./exchange/spot/tickers");
var trades_2 = require("./exchange/spot/trades");
var nba_1 = require("./nba");
var nfl_1 = require("./nfl");
var debug = debug_1.default('sb-api:validation');
/**
 * How many errors we're maximally going to report
 * and print
 */
var NUM_ERRORS = 5;
var DataValidationError = /** @class */ (function (_super) {
    __extends(DataValidationError, _super);
    function DataValidationError(msg) {
        var _this = _super.call(this, msg) || this;
        _this.name = 'DataValidationError';
        return _this;
    }
    return DataValidationError;
}(Error));
exports.DataValidationError = DataValidationError;
var validate = function (data, type, onError) {
    if (Array.isArray(data)) {
        debug("Validating %O $", data.slice(0, 3));
        if (data.length > 3) {
            debug('( + %d more elements)', data.length - 3);
        }
    }
    else {
        debug("Validating %O $", data);
    }
    var decodedE = type.decode(data);
    var decoded = decodedE.getOrElseL(function () {
        var paths = PathReporter_1.PathReporter.report(decodedE);
        debug('Got errors while validating a %s!', type.name);
        var pathsStr;
        if (paths.length <= NUM_ERRORS) {
            var joinedPaths = paths.join('\n');
            debug('%s', joinedPaths);
            pathsStr = joinedPaths;
        }
        else {
            var firstErrors = "First " + NUM_ERRORS + ": " + paths.slice(0, NUM_ERRORS).join('\n');
            debug('%s', firstErrors);
            pathsStr = paths.length + " errors. " + firstErrors;
        }
        return onError(new DataValidationError(pathsStr));
    });
    debug("Validation of " + type.name + " OK");
    return decoded;
};
exports.SocketValidate = {
    snapshot: function (msg, type, onError) {
        var msgStr = msg.toString();
        var json = JSON.parse(msgStr);
        debug('Got snapshot validation request for %s', type.name);
        var uuid = json.uuid, snapshot = json.snapshot;
        if (!uuid) {
            return onError("Message " + msgStr + " has no UUID");
        }
        else if (!snapshot) {
            return onError("Message " + msgStr + " has no 'snapshot' field!");
        }
        else if (!Array.isArray(snapshot)) {
            return onError("Snapshot in message " + msgStr + " is not an array!");
        }
        var decoded = validate(snapshot, type, onError);
        debug('Snapshot validation OK');
        return { uuid: uuid, snapshot: decoded };
    },
    data: function (msg, type, onError) {
        var msgStr = msg.toString();
        var json = JSON.parse(msgStr);
        debug('Got data validation request for %s', type.name);
        var uuid = json.uuid, data = json.data;
        if (Array.isArray(data)) {
            debug("Data is array with " + data.length + " elements");
            var firstElem = data[0];
            if (firstElem) {
                debug('First element: %O', firstElem);
            }
        }
        if (!uuid) {
            return onError("Message " + msgStr + " has no UUID!");
        }
        else if (!data) {
            return onError("Message " + msgStr + " has no 'data' field!");
        }
        var decoded = validate(data, type, onError);
        debug('Data message validation OK');
        return { uuid: uuid, data: decoded };
    },
};
exports.RestValidate = {
    data: function (data, type) {
        return validate(data, type, function (err) {
            debug("Err when validating data: " + err);
            throw err;
        });
    },
};
var PAYMENT_RECEIVED = 'payment received';
var UNSUBSCRIBED = 'unsubscribed';
var ALL_PPC_DATA_RESPONSE_TYPES = nfl_1.NflTypes.ALL_NFL_TYPES.concat(nba_1.NbaTypes.ALL_NBA_TYPES);
var ALL_EXCHANGE_DATA_RESPONSE_TYPES = books_2.ALL_SPOT_BOOKS_DATA_TYPES.concat(tickers_2.ALL_SPOT_TICKERS_DATA_TYPES, trades_2.ALL_SPOT_TRADES_DATA_TYPES, trades_1.ALL_FUTURES_TRADES_DATA_TYPES, books_1.ALL_FUTURES_BOOKS_DATA_TYPES, tickers_1.ALL_FUTURES_TICKERS_DATA_TYPES);
var MessageTypes = /** @class */ (function () {
    function MessageTypes() {
    }
    MessageTypes.Welcome = t.type({
        message: t.string,
        ln_uri: t.string,
        version: t.Integer,
        openChannels: t.array(t.string),
    }, 'InitMsgType');
    MessageTypes.Invoice = t.type({
        uuid: types.uuid,
        invoice: t.string,
    }, 'LnInvoiceType');
    MessageTypes.isInfoType = function (type) { return type === nba_1.NbaTypes.InfoType || type === nfl_1.NflTypes.InfoType; };
    MessageTypes.isInvoice = function (msg) { return typeof msg.invoice === 'string'; };
    MessageTypes.isSnapshot = function (msg) {
        return msg.snapshot && Array.isArray(msg.snapshot) && typeof msg.uuid === 'string';
    };
    MessageTypes.isInitMsg = function (msg) { return typeof msg.ln_uri === 'string'; };
    MessageTypes.hasUuid = function (msg) { return typeof msg.uuid === 'string'; };
    MessageTypes.hasDataAndUuid = function (msg) {
        return Array.isArray(msg.data) && MessageTypes.hasUuid(msg);
    };
    MessageTypes.isPpcDataResponse = function (msg, type) {
        return msg && ALL_PPC_DATA_RESPONSE_TYPES.includes(type);
    }; // the && is to avoid TS nagging about unused param
    MessageTypes.isExchangeDataResponse = function (msg, type) {
        return msg && msg.data && ALL_EXCHANGE_DATA_RESPONSE_TYPES.includes(type);
    };
    MessageTypes.isPaymentReceived = function (msg) {
        return typeof msg.uuid === 'string' &&
            typeof msg.exchange === 'string' &&
            typeof msg.duration === 'number' &&
            msg.event === PAYMENT_RECEIVED &&
            typeof msg.symbol === 'string';
    };
    MessageTypes.isTimeWarning = function (msg) {
        return typeof msg.uuid === 'string' && msg.warnings !== undefined && typeof msg.warnings.duration === 'number';
    };
    MessageTypes.isUnubscribed = function (msg) {
        return typeof msg.uuid === 'string' && msg.event === UNSUBSCRIBED && typeof msg.amountRefunded === 'number';
    };
    return MessageTypes;
}());
exports.MessageTypes = MessageTypes;
