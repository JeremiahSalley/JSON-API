import * as t from 'io-ts';
export declare const ExchangeFuturesTickersTypes: {
    kraken: {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            ask: t.NumberC;
            bid: t.NumberC;
            eventTime: t.RefinementC<t.NumberC>;
            index: t.NumberC;
            last: t.NumberC;
            leverage: t.StringC;
            maturationInterval: t.KeyofC<{
                perpetual: t.NullC;
                monthly: t.NullC;
                quarterly: t.NullC;
                biquarterly: t.NullC;
            }>;
            markPrice: t.NumberC;
            openInterest: t.NumberC;
            priceChange: t.NumberC;
            volume: t.NumberC;
        }>, t.PartialC<{
            /**
             * Only present if subscribing to perpetual contracts
             */
            maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
            /**
             * Only present if subscribing to perpetual contracts
             */
            nextFundingRateTime: t.NumberC;
            /**
             * Only present if subscribing to perpetual contracts
             */
            fundingRate: t.NumberC;
            /**
             * Only present if subscribing to perpetual contracts
             */
            fundingRatePrediction: t.NumberC;
        }>]>, t.TypeC<{
            askSize: t.NumberC;
            bidSize: t.NumberC;
            premium: t.NumberC;
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            ask: t.NumberC;
            bid: t.NumberC;
            eventTime: t.RefinementC<t.NumberC>;
            index: t.NumberC;
            last: t.NumberC;
            leverage: t.StringC;
            maturationInterval: t.KeyofC<{
                perpetual: t.NullC;
                monthly: t.NullC;
                quarterly: t.NullC;
                biquarterly: t.NullC;
            }>;
            markPrice: t.NumberC;
            openInterest: t.NumberC;
            priceChange: t.NumberC;
            volume: t.NumberC;
        }>, t.PartialC<{
            /**
             * Only present if subscribing to perpetual contracts
             */
            maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
            /**
             * Only present if subscribing to perpetual contracts
             */
            nextFundingRateTime: t.NumberC;
            /**
             * Only present if subscribing to perpetual contracts
             */
            fundingRate: t.NumberC;
            /**
             * Only present if subscribing to perpetual contracts
             */
            fundingRatePrediction: t.NumberC;
        }>]>, t.TypeC<{
            askSize: t.NumberC;
            bidSize: t.NumberC;
            premium: t.NumberC;
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
        }>]>>;
    };
    bitmex: {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            ask: t.NumberC;
            bid: t.NumberC;
            eventTime: t.RefinementC<t.NumberC>;
            index: t.NumberC;
            last: t.NumberC;
            leverage: t.StringC;
            maturationInterval: t.KeyofC<{
                perpetual: t.NullC;
                monthly: t.NullC;
                quarterly: t.NullC;
                biquarterly: t.NullC;
            }>;
            markPrice: t.NumberC;
            openInterest: t.NumberC;
            priceChange: t.NumberC;
            volume: t.NumberC;
        }>, t.PartialC<{
            /**
             * Only present if subscribing to perpetual contracts
             */
            maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
            /**
             * Only present if subscribing to perpetual contracts
             */
            nextFundingRateTime: t.NumberC;
            /**
             * Only present if subscribing to perpetual contracts
             */
            fundingRate: t.NumberC;
            /**
             * Only present if subscribing to perpetual contracts
             */
            fundingRatePrediction: t.NumberC;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                /**
                 * Only present if subscribing to perpetual contracts
                 */
                ETHBTC: t.NullC;
            }>;
            low: t.NumberC;
            high: t.NumberC;
            volWeightedAvePrice: t.NumberC;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            ask: t.NumberC;
            bid: t.NumberC;
            eventTime: t.RefinementC<t.NumberC>;
            index: t.NumberC;
            last: t.NumberC;
            leverage: t.StringC;
            maturationInterval: t.KeyofC<{
                perpetual: t.NullC;
                monthly: t.NullC;
                quarterly: t.NullC;
                biquarterly: t.NullC;
            }>;
            markPrice: t.NumberC;
            openInterest: t.NumberC;
            priceChange: t.NumberC;
            volume: t.NumberC;
        }>, t.PartialC<{
            /**
             * Only present if subscribing to perpetual contracts
             */
            maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
            /**
             * Only present if subscribing to perpetual contracts
             */
            nextFundingRateTime: t.NumberC;
            /**
             * Only present if subscribing to perpetual contracts
             */
            fundingRate: t.NumberC;
            /**
             * Only present if subscribing to perpetual contracts
             */
            fundingRatePrediction: t.NumberC;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                /**
                 * Only present if subscribing to perpetual contracts
                 */
                ETHBTC: t.NullC;
            }>;
            low: t.NumberC;
            high: t.NumberC;
            volWeightedAvePrice: t.NumberC;
        }>]>>;
    };
};
export declare const ALL_FUTURES_TICKERS_DATA_TYPES: (t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    ask: t.NumberC;
    bid: t.NumberC;
    eventTime: t.RefinementC<t.NumberC>;
    index: t.NumberC;
    last: t.NumberC;
    leverage: t.StringC;
    maturationInterval: t.KeyofC<{
        perpetual: t.NullC;
        monthly: t.NullC;
        quarterly: t.NullC;
        biquarterly: t.NullC;
    }>;
    markPrice: t.NumberC;
    openInterest: t.NumberC;
    priceChange: t.NumberC;
    volume: t.NumberC;
}>, t.PartialC<{
    /**
     * Only present if subscribing to perpetual contracts
     */
    maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
    /**
     * Only present if subscribing to perpetual contracts
     */
    nextFundingRateTime: t.NumberC;
    /**
     * Only present if subscribing to perpetual contracts
     */
    fundingRate: t.NumberC;
    /**
     * Only present if subscribing to perpetual contracts
     */
    fundingRatePrediction: t.NumberC;
}>]>, t.TypeC<{
    askSize: t.NumberC;
    bidSize: t.NumberC;
    premium: t.NumberC;
    symbol: t.KeyofC<{
        BTCUSD: t.NullC;
        ETHUSD: t.NullC;
    }>;
}>]>> | t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    ask: t.NumberC;
    bid: t.NumberC;
    eventTime: t.RefinementC<t.NumberC>;
    index: t.NumberC;
    last: t.NumberC;
    leverage: t.StringC;
    maturationInterval: t.KeyofC<{
        perpetual: t.NullC;
        monthly: t.NullC;
        quarterly: t.NullC;
        biquarterly: t.NullC;
    }>;
    markPrice: t.NumberC;
    openInterest: t.NumberC;
    priceChange: t.NumberC;
    volume: t.NumberC;
}>, t.PartialC<{
    /**
     * Only present if subscribing to perpetual contracts
     */
    maturationTime: t.BrandC<t.NumberC, t.IntBrand>;
    /**
     * Only present if subscribing to perpetual contracts
     */
    nextFundingRateTime: t.NumberC;
    /**
     * Only present if subscribing to perpetual contracts
     */
    fundingRate: t.NumberC;
    /**
     * Only present if subscribing to perpetual contracts
     */
    fundingRatePrediction: t.NumberC;
}>]>, t.TypeC<{
    symbol: t.KeyofC<{
        BTCUSD: t.NullC;
        ETHUSD: t.NullC;
        /**
         * Only present if subscribing to perpetual contracts
         */
        ETHBTC: t.NullC;
    }>;
    low: t.NumberC;
    high: t.NumberC;
    volWeightedAvePrice: t.NumberC;
}>]>>)[];
