import * as t from 'io-ts';
export declare const ExchangeFuturesTradesTypes: {
    kraken: {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            tradeTime: t.RefinementC<t.NumberC>;
            marketMaker: t.BooleanC;
            price: t.NumberC;
            quantity: t.BrandC<t.NumberC, t.IntBrand>;
        }>, t.PartialC<{
            /**
             * Only present for non-perpetual futures
             */
            maturationTime: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
        }>, t.PartialC<{
            reason: t.KeyofC<{
                fill: t.NullC;
                liquidation: t.NullC;
                termination: t.StringC;
            }>;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            tradeTime: t.RefinementC<t.NumberC>;
            marketMaker: t.BooleanC;
            price: t.NumberC;
            quantity: t.BrandC<t.NumberC, t.IntBrand>;
        }>, t.PartialC<{
            /**
             * Only present for non-perpetual futures
             */
            maturationTime: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
            }>;
        }>, t.PartialC<{
            reason: t.KeyofC<{
                fill: t.NullC;
                liquidation: t.NullC;
                termination: t.StringC;
            }>;
        }>]>>;
    };
    bitmex: {
        data: t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            tradeTime: t.RefinementC<t.NumberC>;
            marketMaker: t.BooleanC;
            price: t.NumberC;
            quantity: t.BrandC<t.NumberC, t.IntBrand>;
        }>, t.PartialC<{
            /**
             * Only present for non-perpetual futures
             */
            maturationTime: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            tradeId: import("io-ts-types").uuidC;
            grossValue: t.RefinementC<t.NumberC>;
            homeNotional: t.NumberC;
            foreignNotional: t.NumberC;
        }>]>>;
        snapshot: t.ArrayC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
            tradeTime: t.RefinementC<t.NumberC>;
            marketMaker: t.BooleanC;
            price: t.NumberC;
            quantity: t.BrandC<t.NumberC, t.IntBrand>;
        }>, t.PartialC<{
            /**
             * Only present for non-perpetual futures
             */
            maturationTime: t.RefinementC<t.NumberC>;
        }>]>, t.TypeC<{
            symbol: t.KeyofC<{
                BTCUSD: t.NullC;
                ETHUSD: t.NullC;
                ETHBTC: t.NullC;
            }>;
            tradeId: import("io-ts-types").uuidC;
            grossValue: t.RefinementC<t.NumberC>;
            homeNotional: t.NumberC;
            foreignNotional: t.NumberC;
        }>]>>;
    };
};
export declare const ALL_FUTURES_TRADES_DATA_TYPES: (t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    tradeTime: t.RefinementC<t.NumberC>;
    marketMaker: t.BooleanC;
    price: t.NumberC;
    quantity: t.BrandC<t.NumberC, t.IntBrand>;
}>, t.PartialC<{
    /**
     * Only present for non-perpetual futures
     */
    maturationTime: t.RefinementC<t.NumberC>;
}>]>, t.TypeC<{
    symbol: t.KeyofC<{
        BTCUSD: t.NullC;
        ETHUSD: t.NullC;
    }>;
}>, t.PartialC<{
    reason: t.KeyofC<{
        fill: t.NullC;
        liquidation: t.NullC;
        termination: t.StringC;
    }>;
}>]>> | t.RefinementC<t.IntersectionC<[t.IntersectionC<[t.TypeC<{
    tradeTime: t.RefinementC<t.NumberC>;
    marketMaker: t.BooleanC;
    price: t.NumberC;
    quantity: t.BrandC<t.NumberC, t.IntBrand>;
}>, t.PartialC<{
    /**
     * Only present for non-perpetual futures
     */
    maturationTime: t.RefinementC<t.NumberC>;
}>]>, t.TypeC<{
    symbol: t.KeyofC<{
        BTCUSD: t.NullC;
        ETHUSD: t.NullC;
        ETHBTC: t.NullC;
    }>;
    tradeId: import("io-ts-types").uuidC;
    grossValue: t.RefinementC<t.NumberC>;
    homeNotional: t.NumberC;
    foreignNotional: t.NumberC;
}>]>>)[];
